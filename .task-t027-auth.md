# Task T027: Authentication System

**Status:** IN PROGRESS  
**Started:** 2025-12-01  
**Assignee:** Developer Agent

---

## Objectives

Implement API key-based authentication for the HTTP API layer with:
- Secure API key generation and storage
- Permission-based access control (read, write, admin)
- Authentication middleware integration
- CLI commands for key management

---

## Design Decisions

### Storage Format
- **Location:** `~/.libreseed/api-keys.yaml`
- **Format:** YAML with encrypted keys
- **Schema:**
  ```yaml
  keys:
    - id: uuid-v4
      name: "My API Key"
      key_hash: sha256-hash  # Store hash, not plaintext
      level: read|write|admin
      created_at: 2025-12-01T09:00:00Z
      last_used: 2025-12-01T10:30:00Z
      revoked: false
  ```

### Permission Levels
- **read:** Can only view data (GET endpoints)
- **write:** Can view and modify (GET, POST, DELETE on packages)
- **admin:** Full access including key management and system config

### API Key Format
- **Generation:** `crypto/rand` for security
- **Format:** `lbs_<32-char-hex>` (e.g., `lbs_a1b2c3d4e5f6...`)
- **Validation:** Prefix check + length check + hash lookup

### Authentication Flow
1. Client sends: `Authorization: Bearer lbs_<key>`
2. Middleware extracts key from header
3. Hash key and lookup in storage
4. Verify not revoked and check permission level
5. Inject key context into request
6. Allow/deny based on endpoint permissions

---

## Implementation Plan

### Step 1: API Key Storage (`pkg/api/apikeys.go`)
```go
type APIKey struct {
    ID        string    `yaml:"id"`
    Name      string    `yaml:"name"`
    KeyHash   string    `yaml:"key_hash"`
    Level     string    `yaml:"level"`
    CreatedAt time.Time `yaml:"created_at"`
    LastUsed  time.Time `yaml:"last_used"`
    Revoked   bool      `yaml:"revoked"`
}

type APIKeyStore struct {
    Keys []APIKey `yaml:"keys"`
}

// Methods:
// - GenerateKey(name, level) (key string, err error)
// - ValidateKey(key string) (*APIKey, error)
// - ListKeys() ([]APIKey, error)
// - RevokeKey(id string) error
// - UpdateLastUsed(id string) error
```

### Step 2: Authentication Middleware (`pkg/api/auth.go`)
```go
func (r *Router) AuthMiddleware(requiredLevel string) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
            // Extract Bearer token
            // Validate key
            // Check permission level
            // Inject key context
            // Call next handler or return 401/403
        })
    }
}
```

### Step 3: Context Integration
```go
type contextKey string

const (
    APIKeyContextKey contextKey = "api_key"
)

// Helper functions
func GetAPIKeyFromContext(ctx context.Context) *APIKey
func WithAPIKey(ctx context.Context, key *APIKey) context.Context
```

### Step 4: CLI Commands (`cmd/lbs/apikey.go`)
```bash
lbs api-key create --name "My Key" --level read
lbs api-key list
lbs api-key revoke <key-id>
```

### Step 5: Update Router with Auth
```go
// Protected routes
router.Use(r.AuthMiddleware("read"))

// Admin-only routes
adminRoutes := router.PathPrefix("/api/v1/admin").Subrouter()
adminRoutes.Use(r.AuthMiddleware("admin"))
```

---

## Files to Create

1. **`pkg/api/apikeys.go`** - Key storage and management
2. **`pkg/api/auth.go`** - Authentication middleware
3. **`cmd/lbs/apikey.go`** - CLI commands
4. **`pkg/api/auth_test.go`** - Authentication tests

## Files to Modify

1. **`pkg/api/router.go`** - Integrate auth middleware
2. **`pkg/api/middleware.go`** - Add auth middleware to chain

---

## Testing Strategy

### Unit Tests
- Key generation randomness
- Hash validation
- Permission level checks
- Revoked key rejection
- Invalid token format rejection

### Integration Tests
- Full authentication flow
- Permission level enforcement
- Key lifecycle (create → use → revoke)
- CLI command execution

---

## Security Considerations

1. **Key Generation:** Use `crypto/rand` for cryptographic randomness
2. **Storage:** Hash keys with SHA-256 before storing
3. **Transmission:** Always use HTTPS in production
4. **Rate Limiting:** Apply rate limits per API key (future: T032)
5. **Audit Trail:** Log all key creation/revocation events
6. **Key Rotation:** Document key rotation best practices

---

## Success Criteria

- ✅ API keys can be generated with secure randomness
- ✅ Keys are stored securely (hashed, not plaintext)
- ✅ Authentication middleware correctly validates keys
- ✅ Permission levels are enforced per endpoint
- ✅ CLI commands work correctly
- ✅ All tests pass (unit + integration)
- ✅ Documentation updated

---

## Next Steps

1. Create `pkg/api/apikeys.go` with key storage logic
2. Implement `pkg/api/auth.go` with authentication middleware
3. Add CLI commands in `cmd/lbs/apikey.go`
4. Write comprehensive tests
5. Update router to use authentication
6. Update documentation

---

**Ready to begin implementation!**
